--- a/scanner.h	2017-08-24 18:28:25.000000000 +0100
+++ b/scanner.h	2017-09-16 12:23:15.273425331 +0100
@@ -83,4 +83,7 @@
 void
 start_scanner();
 
+void
+start_rescan();
+
 #endif
--- a/minidlna.c	2017-08-24 18:28:25.000000000 +0000
+++ b/minidlna.c	2018-07-22 20:02:36.147538630 +0000
@@ -95,6 +95,7 @@
 #include "tivo_beacon.h"
 #include "tivo_utils.h"
 #include "avahi.h"
+#include "libav.h"
 
 #if SQLITE_VERSION_NUMBER < 3005001
 # warning "Your SQLite3 library appears to be too old!  Please use 3.5.1 or newer."
@@ -160,7 +161,6 @@
 static void
 sigusr1(int sig)
 {
-	signal(sig, sigusr1);
 	DPRINTF(E_WARN, L_GENERAL, "received signal %d, clear cache\n", sig);
 
 	memset(&clients, '\0', sizeof(clients));
@@ -169,10 +169,11 @@
 static void
 sighup(int sig)
 {
-	signal(sig, sighup);
-	DPRINTF(E_WARN, L_GENERAL, "received signal %d, re-read\n", sig);
+	setlocale(LC_COLLATE, "");
+	av_register_all();
+	av_log_set_level(AV_LOG_PANIC);
 
-	reload_ifaces(1);
+	start_rescan();
 }
 
 /* record the startup time */
@@ -363,6 +364,10 @@
 	}
 	if (ret || GETFLAG(RESCAN_MASK))
 	{
+		sigset_t mask;
+		sigemptyset(&mask);
+		sigaddset(&mask, SIGHUP);
+		pthread_sigmask(SIG_BLOCK, &mask, NULL);
 #if USE_FORK
 		SETFLAG(SCANNING_MASK);
 		sqlite3_close(db);
@@ -370,6 +375,8 @@
 		open_db(&db);
 		if (*scanner_pid == 0) /* child (scanner) process */
 		{
+			signal(SIGHUP, SIG_IGN);
+			
 			start_scanner();
 			sqlite3_close(db);
 			log_close();
@@ -384,6 +391,7 @@
 #else
 		start_scanner();
 #endif
+		pthread_sigmask(SIG_UNBLOCK, &mask, NULL);
 	}
 }
 
@@ -979,9 +987,11 @@
 		DPRINTF(E_FATAL, L_GENERAL, "Failed to set %s handler. EXITING.\n", "SIGINT");
 	if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
 		DPRINTF(E_FATAL, L_GENERAL, "Failed to set %s handler. EXITING.\n", "SIGPIPE");
-	if (signal(SIGHUP, &sighup) == SIG_ERR)
+	sa.sa_handler = sighup;
+	if (sigaction(SIGHUP, &sa, NULL))
 		DPRINTF(E_FATAL, L_GENERAL, "Failed to set %s handler. EXITING.\n", "SIGHUP");
-	signal(SIGUSR1, &sigusr1);
+	sa.sa_handler = sigusr1;
+	sigaction(SIGUSR1, &sa, NULL);
 	sa.sa_handler = process_handle_child_termination;
 	if (sigaction(SIGCHLD, &sa, NULL))
 		DPRINTF(E_FATAL, L_GENERAL, "Failed to set %s handler. EXITING.\n", "SIGCHLD");
--- a/process.c	2017-08-24 18:28:25.000000000 +0000
+++ b/process.c	2018-07-22 19:57:53.476166882 +0000
@@ -93,14 +93,24 @@
 		return -1;
 	}
 
+	sigset_t mask;
+	sigemptyset(&mask);
+	sigaddset(&mask, SIGHUP);
+	pthread_sigmask(SIG_BLOCK, &mask, NULL);
+
 	pid_t pid = fork();
-	if (pid > 0)
+	if (pid)
 	{
-		if (client)
-			client->connections++;
-		add_process_info(pid, client);
-		number_of_children++;
-	}
+		pthread_sigmask(SIG_UNBLOCK, &mask, NULL);
+		
+		if (pid > 0) {
+			if (client)
+				client->connections++;
+			add_process_info(pid, client);
+			number_of_children++;
+		}
+	} else
+		signal(SIGHUP, SIG_IGN);
 
 	return pid;
 }
